

Angular is written in TypeScript.
NgModules
The basic building blocks of an Angular application are NgModules, which provide a compilation context for components.
An NgModule is defined by a class decorated with @NgModule(). 
Components
Components define views, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.
services
Components use services, which provide specific functionality not directly related to views
root module or AppModule
Every Angular app has a root module, conventionally named AppModule, which provides the bootstrap mechanism that launches the application



Node.js
Node.js is an open-source, cross-platform JavaScript run-time environment that executes JavaScript code outside of a browser.

npm
The npm package gets installed along with nodejs.
npm is a package manager for the JavaScript programming language. 
It is the default package manager for the JavaScript runtime environment Node.js. 

TypeScript 
Angular6 uses TypeScript 2.9 version  
Angular 4 uses TypeScript version 2.2. 
TypeScript is an open-source programming language developed and maintained by Microsoft. 
TypeScript is designed for development of large applications and transcompiles to JavaScript.

Angular 6
Angular team came up with Angular CLI which eases the installation.
npm install -g @angular/cli //command to install angular 6

Visual Studio Code
We will use Visual Studio Code IDE for working with Angular 6; you can use any IDE, i.e., Atom, WebStorm, etc.

------------------------------------

01 Install Node.js and nmp
	https://nodejs.org/en/
	
	Angular requires Node.js version 8.x or 10.x.
	node -v  : To check your version, run node -v in a terminal/console window.
	npm -v : To check the npm version
	
02 Visual Studio Code

03 Install the Angular CLI

	Install Globablly:
		npm install -g @angular/cli
	
	Install Locally:
		npm install @angular/cli
		
	Refer:
		https://www.npmjs.com/package/@angular/cli
	
	To find Angular CLI version:
		ng v
		
	To find available commands:
		ng -v
		or
		ng --v
		
	Refer for the issue "ng not recognized...":
	Refer To set up PATH in Environment Variables:
		https://stackoverflow.com/questions/37991556/ng-is-not-recognized-as-an-internal-or-external-command
		
--------------------------------------------
ng new 
//To create a new workspace and an initial app project:
ex:
ng new my-angular-app

ng serve
or
ng s
//To Build and serve our app, and rebuilding on file changes
ex:
cd my-angular-app  //Go to the workspace folder 
ng serve

ng serve --open
//The --open flag opens a browser to http://localhost:4200/.

==========================================================================
Solution for the port issue:
Issue: “Port 4200 is already in use” when running the ng serve command

Solution:
01. Open your cmd.exe as administrator
02. then Find the PID of port 4200
	netstat -ano | findstr :4200
	We will get an output like below:
	TCP    127.0.0.1:4200         0.0.0.0:0              LISTENING       9968
03. kill only port 4200
	taskkill /PID 9968 /F

04. now you can do "ng-serve" to start your angular app at the same port 4200

==========================================================================
For folder structure and File description refer below url.
	https://www.tutorialspoint.com/angular6/angular6_project_setup.htm
	
app
It contains the files described below. These files are installed by angular-cli by default.

app.module.ts 
	This code has reference to different libraries, which are imported. 
	Angular-cli has used these default libraries for the import - angular/core, platform-browser. 
	They are imported and saved into variables such as declarations, imports, providers, and bootstrap.
	
	declarations − In declarations, the reference to the components is stored. 
	imports − This will have the modules imported
	providers − This will have reference to the services created.
	bootstrap − This has reference to the default component created, i.e., AppComponent.

Component:
app.component.ts 
	The class for the component is defined over here. You can do the processing of the html structure in the .ts file. 
	The processing will include activities such as connecting to the database, interacting with other components, routing, services, etc.
app.component.html 
	The html code will be available in this file.	
app.component.spec.ts 
	These are automatically generated files which contain unit tests for source component.
index.html
This is the file which is displayed in the browser.
The body has <app-root></app-root>. This is the selector which is used in app.component.ts file and will display the details from app.component.html file.


Template VS Template URL:
Template:
We can write html code in template.
If the html is in single line then we can write its within a single quotes ('') OR back tick(``)
If the html code is more than one line the we should use within a back tick(``)

Template URL:
USed to specify the path of the html file

Interpolation:
--------------
It is a data binding. Passing data from component class to html. 
Binding value using {{ }}	
Properties in a component class can be bind to the html using {{ }}, its called interpolation
Examples:
	{{ Name}}
	{{ 10+20+10}}	//This display the sum 40 in UI
	{{firstName ? firstName : 'No name specified'}}	//Conditional operators can be used
	 <img src='{{imagePath}}'/>   //Image path can be set using interpolation
We can also call class method using interpolation
	<h3 style="text-align:left">Employee {{ getFullName()}}</h3>  
	//Here, getFullName is a method name from component class
	
One way and two way data binding
	-From component to view template binding
	-From View Template to Component
Two way binding from Component to View Template and From View Template to Component data binding

Property binding
---------------
Its also Passing data from component class to html. 
Its one way data binding
Example:
	<img [src]='titleImagePath'/>  
	<button [disabled]='isDisabled'>Click Me</button>
	<button bind-disabled='isDisabled'>Click Me</button> //Canonical way

The difference between Interpolation and Property binding
	>Interpolation is a special syntax that Angular converts into a property binding. 
	>Interpolation is just a convenient alternative to property binding. 

Difference between HTML attribute and DOM property.	
--------------------------------------------------
	Angular data binding is to the DOM elements, not to the html attributes.
	DOM stands for Document Object Model. 
	When a browser loads a web page, the browser creates a Document Object Model of that page. 
	
What is the difference between HTML element attribute and DOM property
	Attributes are defined by HTML, where as properties are defined by the DOM.
	Attributes initialize DOM properties. Once the initialization complete, the attributes job is done.
	Property values can change, where as attribute values can't.
Ex:
	<input id='inputId' type='text' value='Tom'>
	http://csharp-video-tutorials.blogspot.com/2017/06/html-attribute-vs-dom-property.html
	
	inputId.getAttribute('value') //getting the attribute value
	inputId.value //getting the property value
	
	Even if we change the value in textbox, the attribute value will be always 'Tom'
	But property value will change, if we change the value in textbox 

Attribute Binding
-----------------	
Attribute Binding using interpolation example:
	Use "attr." along with attribute for attribute binding. 
	1. Use of interpolation for Attribute Binding
		<th attr.colspan="{{columnSpan}}">
	2. Other ways
		<th [attr.colspan]="columnSpan">
	3.  <th colspan='columnSpan'>
	
	
CSS Class Binding
-----------------
Examples:
	Create a class property 'cssClassToApply' and assign css classes to that
		cssClassToApply='boldClass colorClass';
		isApplyColorClass=true;
	Then bind this property to the html class property

	<button [class]="cssClassToApply">CSS Class binding example</button>
    >> In above example both 'boldClass colorClass' classes will apply to the button
		
	<button class="italicsClass" [class.colorClass]="isApplyColorClass">CSS Class binding with condition</button>
	>> In above example 'italicsClass' will apply to the button
	>> And 'colorClass' will apply if "isApplyColorClass=true", which is setting in .ts file
	>> Also we can Use "!". 
		Ex:[class.colorClass]="!isApplyColorClass"
	
	Same way we can remove a css class also
	Ex:
	<button class="boldClass italicsClass colorClass" [class.colorClass]="!isApplyColorClass">
	>> Here all 3 classes are applied but 'colorClass' will remove or apply based on 'isApplyColorClass' value
	
Using [ngClass]:
		Ex: 
		<button class="italicsClass" [ngClass]='addCssUsingNgClass1()'>CSS Class using ngClass</button>
		
		>> Here addCSSClasses() is a method/class returning css class names 
		
		isApplyColorClass=true;
		isApplyBoldClass=true;
		
		Ex 01.>>
		addCssUsingNgClass1(){
			let classes={
			  colorClass:this.isApplyColorClass,
			  boldClass:this.isApplyBoldClass
			};
			return classes;
		  }
		
		Ex 02.>>
		addCssUsingNgClass2(){
			//return 'boldClass colorClass';
			//OR
			return { boldClass:this.isApplyBoldClass};
		}
		
		
Style binding 
--------------
	Create class properties like
		isBold=true;
		fontSize=20;
	
	Example:
	 <button style="color:blue" [style.font-weight]="isBold? 'bold':'normal'" 
                                [style.font-size.px]="fontSize">Inline Style binding</button>

Using ngStyle:

	>> Create a method
	
	addStyleUsingNgStyle(){
		return { 'font-weight': this.isBold? 'bold':'Normal',
				  'font-style':'Italic'};
	}
	
	>> Use this class in [ngStyle] property
	Example:
	<button [ngStyle]="addStyleUsingNgStyle()">Inline Style binding using ngStyle</button>
	
	
Event Binding
-------------	
	>> Use (click) or on-click to bind click event
	>> Use parentheses symbol () with events to bind it to the html control
	Ex:
		<button (click)='onClick()'>Event binding</button>
	
	>> Also we can use "on-" along with event to bind it
	Ex:
		<button on-click='onClick()'>Event binding-2</button>
	

*ngIf  (A  structural directive)
-----------
		>> *ngIf - The ng-if directive removes the HTML element if the expression evaluates to false.
		>> * symbol indicates that its a structural directive
		Ex:
			<tr *ngIf='showDetails'>
			
		>> If the 'showDetails' value is false, then the <tr> won't bind to the DOM
		>> ngIf : structural directive which conditionally adds or removes DOM elements.
		
[(ngModel]  Two way data Binding
-------------------

	>> Use [(ngModel] for two way data binding
	Ex:
		Name: <input type="text" [(ngModel)]='name'/>
        <span>You entered: {{name}} </span>
		
	>> [(ngModel] is a combination of both property binding "[]" and event binding "()" for two way data binding
	>> To avail ngModel, In app.module.ts file, we have to import forms module from angular forms
		Here are the steps to import FormsModule into our AppModule
		1. Open app.module.ts file
		2. Include the following import statement in it
			import { FormsModule } from '@angular/forms';
		3. Also, include FormsModule in the 'imports' array of @NgModule
			imports: [BrowserModule, FormsModule]


*ngFor (A structural directive)
----------
	>> *ngFor is usually used to display an array or list of items
	>> * symbol indicates that its a structural directive
	Ex:
		<tr *ngFor="let employee of employees">
            <td>{{employee.code}}</td>
            <td>{{employee.name}}</td>
            <td>{{employee.gender}}</td>
        </tr>

	>> *ngFor='let employee of employees' - In this example 'employee' is called template input variable, 
		which can be accessed by the <tr> element and any of it's child elements.
	>> Use below code to show a message when the employees list empty or not exist
	>> Ex:
		 <tr *ngIf="!employees || employees.length==0">
            <td colspan="3">No employees to display</td>
        </tr>
		
		
*ngFor trackBy:
----------------
	>> trackyBy: is using with *ngFor directive
	>> *ngFor directive may perform poorly with large lists
	>> A small change to the list like, adding a new item or removing an existing item may trigger recreation of entire DOM element(ex:<tr>)
	>> This happens because Angular by default keeps track of objects using the object references.
	>> Angular can avoid this with trackBy:.
	>> Using trackBy: only the changed DOM element will recreate
	Ex:
		trackByEmpCode(index, employee){
			return employee.code;
		}
		
		<tr *ngFor="let employee of employees1;trackBy:trackByEmpCode">
		
	>> Angular is now tracking employee objects using the employee code instead of object references, 
	>> Now, If we try to reload the list using any refresh button, only the changed DOM element(ex:<td>) or newly added DOM element will recreate
	>>> Here, if any "employee.code" value changed then the corresponding entire <tr> itself will recreate
	>>> If only one column value is changed, then only that <td> will recreate
	>>> If any new item is added, then new <tr> will create
	
*ngFor index:
--------------	
	>> Use "index" keyword to find the index of the ngFor list item
	Ex:
		<tr *ngFor="let employee of employees1;trackBy:trackByEmpCode;let i=index">
			<td>{{i}}</td>
			
	>> 
*ngFor first and last
--------------------
	>> Use "first" and "last" keywords to find whether the item is the first or the last item
	Ex:
		<tr *ngFor="let employee of employees1;trackBy:trackByEmpCode;let i=index;let isFirst=first;let isLast=last">
			<td>{{isFirst}}</td>
            <td>{{isLast}}</td>
			
*ngFor even and odd
--------------------
	>> Use "even" and "odd" keywords to find whether the item is the even or the odd item
	Ex:
		<tr *ngFor="let employee of employees1;trackBy:trackByEmpCode;let i=index;let isFirst=first;let isLast=last;let isEven=even; let isOdd=odd;">
			<td>{{isEven}}</td>
            <td>{{isOdd}}</td>
			
			
			
Angular pipes "|"
-----------------

	>> Pipes transform data before display
	>> Built in pipes include lowercase, uppercase, decimal, date, percent, currency etc
	>> To apply a pipe on a bound property use the pipe character " | "
	Examples:	
	uppercase pipe:
	
		<td>{{employee.code | uppercase}}</td>
		
		>> uppercase pipe in this example converts employee code to uppercase
		
	date pipe:
	
		<td>{{employee.dateOfBirth | date:"fullDate"}}</td>
		
		>> This convert the date in full format like "Monday, September 6, 1982"
		>> To use DatePipe, the date should be in MM\DD\YYYY format
		>> https://angular.io/api/common/DatePipe
		
	Chain pipes	:
		>> More than one pipes can be used with an item
		
		<td>{{employee.dateOfBirth | date:"fullDate" | uppercase}}</td>
		<td>{{employee.dateOfBirth | date:"dd/MM/y" | uppercase}}</td>
		
	Date		https://angular.io/api/common/DatePipe
	Decimal		https://angular.io/api/common/DecimalPipe
	Currency	https://angular.io/api/common/CurrencyPipe
	Percent		https://angular.io/api/common/PercentPipe

	
Angular custom pipe
---------------------
	>> We can create a custom pipe Mr. or Miss. prefixed to the employee name
	
	>> Create custom pipe "employee-title.pipe.ts"
		
		import { Pipe, PipeTransform } from '@angular/core';

		@Pipe({
			name:'EmpTitle'  //This will be the pipe name
		})

		export class EmployeeTitle implements PipeTransform{
			//Here 'value' will get the value of the field were we placed this class.
			//If we call this method from 'name' property then name value will available here
			//But 'gender' value explicitly we have to pass
			transform(value, gender){
				return (gender.toLowerCase() == 'male' ? 'Mr. ' : 'Mrs. ') + value;
			}
		}
	
	>> Register "employee-title.pipe.ts" in "app.module.ts"
		import { EmployeeTitle } from './employee/employee-title.pipe';
		
		Also add to the @NgModule declarations
		
	>> Use this pipe in html file as below
		
		<tr *ngFor="let employee of employees1;trackBy:trackByEmpCode">
            <td>{{employee.code | uppercase}}</td>
            <td>{{employee.name | EmpTitle:employee.gender}}</td>
            <td>{{employee.gender}}</td>
			
			
Angular Container and Nested components 			
----------------------------------------AND
Component Input and Output properties
----------------------------------------AND
Custom events using EventEmitter class
---------------------------------------

Nested components 
------------------
	>> Inside a component we can place another component. Its called Nested component
	>> Parent component is called Container component and child component is called Nested component.
	
Input Properties (@Input() )
------------------

	>> Use input property to pass the values from the parent(container) component to the child(nested) component
	>> Use "@Input" decorator to Convert a child component properties to an input property
		parent component: employee-list.component
		child component: employee-count.component
	
	Ex:	>> In child component (employee-count.component.ts)
			@Input()
			all;
		
			@Input()
			male;
			
			@Input()
			female;
			
		>> In child html (employee-count.component.html)
			<span class="radioClass">Show : </span>

			<input type="radio" name="options" />
			<span class="radioClass">All({{all}})</span>

			<input type="radio" name="options" />
			<span class="radioClass">{{'Male(' + male + ')'}}</span>

			<input type="radio" name="options" />
			<span class="radioClass">{{'Female(' + female + ')'}}</span>

		>> parent component class: employee-list.component.ts
			>> write method to find the count
			
			getTotalEmployeesCount(){
				return this.employees3.length;
			}

			getTotalMaleEmployeesCount(){
				return this.employees3.filter(e=>e.gender==="Male").length;
			}

			getTotalFemaleEmployeesCount(){
				return this.employees3.filter(e=>e.gender==="Female").length;
			}
		
		>> parent component HTML: employee-list.component.html
			>> In parent component HTML, with in <app-employee-count> directive(child component reference)
			>> Bind input property values using property binding
			
			<app-employee-count [all]="getTotalEmployeesCount()"
								[male]="getTotalMaleEmployeesCount()"
								[female]="getTotalFemaleEmployeesCount()"
			></app-employee-count>

			>> Now, the values will be available in input properties of child component
			
		Reference: http://csharp-video-tutorials.blogspot.com/2017/07/angular-component-input-properties.html
		

Angular component 0utput properties ( @Output() ) 
-------------------------------------------------
And Custom events using angular EventEmitter class
-----------------------------------------------
	Refer: http://csharp-video-tutorials.blogspot.com/2017/07/angular-component-output-properties.html

	>> Use output property to pass user actions or user entered values or selections from the child component to the parent component.
	>> To use output property, we have to import Output from '@angular/core'
	>> Use "@Output()" decorator to Convert a child component properties to an output property
		parent component: employee-list.component
		child component: employee-count.component

	Example:
	>> In child component, 
	>> Import Output and EventEmitter(for custom event) from '@angular/core'
		import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
	
		// Holds the selected value of the radio button
		selectedRadioButtonValue = 'All';
  
	  // The Output decorator makes the property an Output property
	  // EventEmitter class is used to create the custom event
	  // When the radio button selection changes, the selected
	  // radio button value which is a string gets passed to the
	  // event handler method. Hence, the event payload is string.
	   @Output()
	   countRadioButtonSelectionChanged: EventEmitter<string>= new EventEmitter<string>();   
	  
	  // This method raises the custom event. 
	  // We will bind this method to the change event of all the 3 radio buttons
		onRadioButtonSelectionChange(){
			this.countRadioButtonSelectionChanged.emit(this.selectedRadioButtonValue);
		}
	
	>> In child component HTML view
		>> Value attribute is set to (All, Male or Female)
		>> The 2 way data-binding using the ngModel ensures whenever the radio button selection changes, 
		   the "selectedRadioButtonValue" property is updated with the value of the selected radio button.
		>> onRadioButtonSelectionChange() method is binded to "change" event of the radio button. 
		>> This means whenever, the selection of the radio button changes, onRadioButtonSelectionChange() method 
			raises the custom event "countRadioButtonSelectionChanged". 
		
		<input type="radio" name="options" value="All" 
											[(ngModel)]="selectedRadioButtonValue" 
											(change)="onRadioButtonSelectionChange()"/>
		<span class="radioClass">All({{all}})</span>

		<input type="radio" name="options" value="Male" 
											[(ngModel)]="selectedRadioButtonValue" 
											(change)="onRadioButtonSelectionChange()"/>
		<span class="radioClass">{{'Male(' + male + ')'}}</span>

		<input type="radio" name="options" value="Female" 
											[(ngModel)]="selectedRadioButtonValue" 
											(change)="onRadioButtonSelectionChange()" />
		<span class="radioClass">{{'Female(' + female + ')'}}</span>
		
	>> In parent component (employee-list.component.ts)
		>> A property to keep track of which radio button is selected
		>> We have set the default value to All, so all the employees are displayed in the table by default
		
		selectedEmployeeCountRadioButton="All"
		
		>> Method to call, when the custom event(countRadioButtonSelectionChanged) inside the child component(Employee-count.component) is raised
		>> The event binding is specified in employee-list.component.html	
		>> This is the Event handler method
	
		onEmployeeCountRadioButtonChange(selectedRadioButtonValue){
			this.selectedEmployeeCountRadioButton=selectedRadioButtonValue;
		}
		
	>> In parent html employee-list.component.html
		<app-employee-count [all]="getTotalEmployeesCount()"
                    [male]="getTotalMaleEmployeesCount()"
                    [female]="getTotalFemaleEmployeesCount()"
                    (countRadioButtonSelectionChanged)="onEmployeeCountRadioButtonChange($event)"
					
					
	>> <ng-container>
		>> In parent html employee-list.component.html
		Example:
			<ng-container *ngFor="let employee of employees3" >
			 <tr *ngIf="selectedEmployeeCountRadioButton=='All' || selectedEmployeeCountRadioButton==employee.gender">
		
		>> In angular, Multiple structural directives(*ngFor, *ngIf) are not allowed in one html element
		>> To avoid this issue we used <ng-container> element and the "ngFor" directive is placed on this element.
		
		
<ng-container>
------------------
	>> In angular, Multiple structural directives(like *ngFor, *ngIf) are not allowed in one html element
	>> To avoid this issue we used <ng-container> element
	>> To avoid this issue we used <ng-container> element and the "ngFor" directive is placed on this element.
	
	Example:
		<ng-container *ngFor="let employee of employees3" >
			 <tr *ngIf="selectedEmployeeCountRadioButton=='All' || selectedEmployeeCountRadioButton==employee.gender">
		
	>> To avoid this issue we used <ng-container> element and the "ngFor" directive is placed on this element.
	

Interfaces in Angular
----------------------
	>> We can use interface in typescript to create our business object(like Employee object).
	>> Example:
		export interface IEmployee {
			code: string;
			name: string;
			gender: string;
			annualSalary: number;
			dateOfBirth: string;
		}
		
	>> Creating Employee object using interface
		employees4: IEmployee[];
	
	>> Normally we can create an Employee object like below
		employees1: any[];
		
	>> To use interface, we have to import interface to the class
	>> Example:
		import { IEmployee } from '../employee';
		
	>> Interface members are public by default and does not require explicit access modifiers.
	>> A class that implements an interface must provide implementation for all the interface members 
	   unless the members are marked as optional using the ? operator
	>> TypeScript interfaces exist for developer convenience and are not used by Angular at runtime.
	>> During transpilation, no JavaScript code is generated for an interface. 
	>> It is only used by Typescript for type checking during development.
	
		
Angular component lifecycle hooks
---------------------------------

ngOnChanges:
	>> Executes, every time the value of an input property changes. 
	>> The hook method receives a "SimpleChanges" object containing current and previous property values. 
	>> This is called before ngOnInit
	
ngOnInit:
	>> Executes after the constructor and after ngOnChange hook for the first time. 
	>> It is most commonly used for component initialisation and retrieving data from a database
	
ngOnDestroy:
	>> Executes just before angular destroys the component and generally used for performing cleanup
	
There are 3 simple steps to use the Life Cycle Hooks:
	>> Step 1 : Import the Life Cycle Hook interface. 
				For example, to use ngOnInit() life cycle hook, import OnInit interface.
				And Import OnChanges, SimpleChanges to use ngOnChanges()
		
			import { OnInit, OnChanges, SimpleChanges } from '@angular/core';
			
	>> Step 2 : Make the component class implement the Life Cycle Hook interface, using the implements keyword as shown below. 
	
			export class OthersComponent implements OnInit, OnChanges { }
			
	>> Step 3 : Write the implementation code for the life cycle interface method. 
				Each interface has a single hook method whose name is the interface name prefixed with ng.
				
				ngOnInit() {
				}
				
				ngOnChanges(changes:SimpleChanges){
					for(let propertyName in changes){
					  let change=changes[propertyName];
					  let currentValue=JSON.stringify(change.currentValue);
					  let previousValue=JSON.stringify(change.previousValue);

					  console.log('CurrentValue: '+currentValue+', PreviousValue: '+ previousValue);
					}
			    }


Angular services tutorial
--------------------------
	>> Service in angular is a type script class
	>> To create a service we have to import Injectable from angular core
		import { Injectable } from '@angular/core';
		
	>> ALso we have to decorate export class with @Injectable()
		@Injectable()
		export class EmployeeService { }
		
	>> To consume the service in component class, we have to import the service
		import{EmployeeService} from '../employee-service';
		
	>> Also we have to Register EmployeeService in this component by declaring it in the providers array
	>> Register our service with angular dependency injection system using providers
	
		Component which consume service: employee-list.component.ts
	
		@Component({
			  selector: 'app-employee-list',
			  templateUrl: './employee-list.component.html',
			  styleUrls: ['./employee-list.component.css'],
			  //// we have to register our service with angular dependency injection system
			  //// Here we have to provide our service class. We can register more than one service.
			  //// Register EmployeeService in this component by declaring it in the providers array
			  providers: [EmployeeService]
		})
		
		
	>> Inject EmployeeService using the constructor
	
			constructor(private _employeeService: EmployeeService) {
				}
			
	>> The private variable _employeeService which points to
	   EmployeeService singelton instance is then available throughout this class

	>> ngOnInit() life cycle hook call the getEmployees() service method of EmployeeService 
	>> using the private variable _employeeService
			
			ngOnInit() {
				this.employees = this._employeeService.getEmployees();
			}
	
	>> the dependency injection is done using the class constructor and 
		the actual service method call is issued from ngOnInit life cycle hook as shown below
		
		employees:IEmployee[];
		constructor(private _employeeService: EmployeeService) { }

		ngOnInit() {
			this.employees = this._employeeService.getEmployees();
		}
	
	Difference between constructor and ngOnInit 
	-------------------------------------------
	>> A class constructor is automatically called when an instance of the class is created. 
		It is generally used to initialise the fields of the class and it's sub classes. 

	>> ngOnInit is a life cycle hook method provided by Angular. 
		ngOnInit is called after the constructor and is generally used to perform tasks related to Angular bindings. 
		For example, ngOnInit is the right place to call a service method to fetch data from a remote server


Angular and ASP.NET Web API
---------------------------

	>> Refer my WebApi study app 
	>> \EmployeeController.cs is the api controller which is used by the angular app
	>> service urls are
			http://localhost:50101/api/employee/GetEmployeeList
			http://localhost:50101/api/employee/GetEmployee/emp103
		
	
Angular 2 http service tutorial (Web API call from angular app)
--------------------------------------------------------------

Step-1: Import HttpClientModule
--------
	>> Angular using the Angular builtin http service to call the Web API service 
	>> Angular builtin http service is present in angular HttpClientModule.(from Angular-4 onwards. For old versions it was HttpModule)
	>> Import the angular HttpClientModule to root application module ('app.module.ts') from '@angular/common/http'
		Root module: app.module.ts
		
		import { HttpClientModule } from '@angular/common/http';
	
	>> Also include HttpClientModule in the imports array of the NgModule() decorator
		@NgModule({
			imports: [
				BrowserModule,
				FormsModule,
				HttpClientModule],
			declarations: [

Step-2: Modify angular EmployeeService to issue any HTTP request
---------
	File: employee-service.ts
	
	>> Modify angular EmployeeService to issue any HTTP request using the builtin http service 
	>> Import HttpClient from '@angular/common/http';
		
		import { HttpClient } from '@angular/common/http';
		
	>> Use the EmployeeService class constructor to inject Angular Http service(HttpClient). 
		
		constructor(private _httpClient:HttpClient){}
	
	>> The injected HttpClient service can then be used anywhere in this class to call a web service over http. 
	>> Since this Angular EmployeeService class has an injected dependency, @Injectable() decorator is required on this class. 
	>> If there are no injectable dependencies then we may omit the @Injectable() decorator
		
		@Injectable()
		export class EmployeeService {
			constructor(private _httpClient:HttpClient){}
			}
			
step-3: Make the service call and method as Observable
---------------------------------------
	File: employee-service.ts
	
	>> From getEmployees() method, Call the web api service by providing the url
	>> We are using the get() method of the angular http service to issue a get request over http.
		
		return this._httpClient.get("http://localhost:50101/api/employee/GetEmployeeList");
		
	>> This http get() method return Observable<Response>.
	>> So, we have to set the return type of getEmployees() method to Observable<IEmployee[]> 
	>> To make the method as Observable we have to import Observable
	>> Import Observable from 'rxjs'. (For old versions import from 'rxjs/Observable')
	
		import { Observable } from 'rxjs';
	
		getEmployees(): Observable<IEmployee[]>{
			return this._httpClient.get("http://localhost:50101/api/employee/GetEmployeeList");
		}
	
	>> Now, the return type of getEmployees() method is  Observable IEmployee array.
	>> So, we need to convert the response of the service call ( get() is Observable by default) also to Observable IEmployee array.
	*****************Following map is not using now. Instead of that we are converting the response to <IEmployee[]>****************
	>> We are using  map operator provided by rxjs to convert the service call response to Observable IEmployee array.
	>> Import map operator provided by rxjs. (for old version: import 'rxjs/add/operator/map';)
		
		import { map } from 'rxjs/operators';
	*********************************************************************************************************************************		
	
	>> Converting the service response to IEmployee array.
	
		return this._httpClient.get<IEmployee[]>("http://localhost:50101/api/employee/GetEmployeeList");
	
	>> Finally the 	service code of "employee-service.ts"
	
		import { Injectable } from '@angular/core';
		import { IEmployee } from './employee';
		//// Import HttpClient to issue any HTTP request using the builtin http service 
		import { HttpClient } from '@angular/common/http';
		import { Observable } from 'rxjs';
	
		@Injectable()
		export class EmployeeService {
			constructor(private _httpClient:HttpClient){}

			getEmployees(): Observable<IEmployee[]>{
				return this._httpClient.get<IEmployee[]>("http://localhost:50101/api/employee/GetEmployeeList");
			}
		}
		
Step 4 - Subscribe to the Observable returned by angular EmployeeService 		
-----------
	File: employee-list.component.ts
	
	>> Corresponding changes is required on angular service consume place ie. 'employee-list.component.ts'
	>> We cannot bind Observable IEmployee(getEmployees() method) directly to employee object
	>> In the ngOnInit() method of "employeeList.component.ts" use the subscribe method
	>> We cant bind Observable of IEmployee(getEmployees() method) directly to the IEmployee array object employees5
	>> To assign we have to subscribe to Observable.
	
		ngOnInit() {
			////this.employees5=this._emplyoeeService.getEmployees();
			this._emplyoeeService.getEmployees()
								.subscribe(employeeData=>this.employees5=employeeData);
		}
		
	>> Above we also specified call back method as a parametr to the subscribe method as a arrow function
    >> Here employeeData receives the employees list and assign to the employees5.
	>> subscribe() function we are passing an arrow function as a parameter. 
	>> This arrow function is called when the Observable emits an item. 
	>> In our case the Observable emits an array of IEmployee objects. 
	>> employeesData parameter receives the array of IEmployee objects, which we are then using to initialise "employees5" property of the EmployeeListComponent class.
	
What is an Observable??
------------------------
	>> Observable is an asynchronous pattern. 
	>> In the Observable pattern we have an Observable and an Observer. Observer observes the Observable. 
	>> In many implementations an Observer is also called as a Subscriber.
	>> An Observable can have many Observers (also called Subscribers).
	>> Observable emits items or notifications over time to which an Observer (also called Subscriber) can subscribe.
	>> When a subscriber subscribes to an Observable, the subscriber also specifies a callback function.
	>> This subscriber callback function is notified as and when the Observable emits items or notifications.
	>> Within this callback function we write code to handle data itmes or notifications received from the Observable.
	
	
	>> In above example we are getting the employee list from web api service call
	>> The Web API call to retrieve employee list is in ngOnInit().
	>> Before the service call can initialise "employees5" property, If we try to access length property of "employees5"
	>> "employees5" property is still undefined at that point, so we get the error - Cannot read property 'length' of undefined. 
	>> To fix this error use angular structural directive *ngIf as shown below.
	>> This will delay the "employees5.length" binding until "employees" property is initialised. 
	
		File: employee-list.component.ts
				getEmployeesCountFromWebAPI(){
					return this.employees5.length;
				}
				
		File: employee-list.component.html
				<span style="font-weight: bold" *ngIf="employees5">{{getEmployeesCountFromWebAPI()}}</span>
	
	>> This <span> will bind only if "employees5" is exist or having value.
	
	
Angular 2 http error handling
------------------------------
	File: employee-service.ts
	
	>> We use the 'catchError' operator to catch any exceptions that occur. 
	>> For that we have to import it
	
		import { map, catchError } from 'rxjs/operators';
	
	>> Add the catchError operator along with http get call
	
		getEmployees(): Observable<IEmployee[]>{
			return this._httpClient.get<IEmployee[]>("http://localhost:50101/api/employee/GetEmployeeList")
									.pipe(
										catchError(this.handleError)
									);
		}
		
		handleError(errorResponse:Response){
			console.error(errorResponse);
			return Observable.throw(errorResponse);
		}
	>>  After we log the error, we are throwing the error back, 
	>> so the components that use this service are notified about the error condition, 
	>> so they can display a meaningful error message to the user.
	
	Pipes(): function in RxJS
	-----------------------------
	You can use pipes to link operators together. 
	Pipes let you combine multiple functions into a single function. 
	The pipe() function takes as its arguments the functions you want to combine, 
	and returns a new function that, when executed, runs the composed functions in sequence.


	File: employee-list.component.ts
	
	



